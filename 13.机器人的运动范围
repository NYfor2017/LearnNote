13.机器人的运动范围
  题目：地上有一个m行n列的方格。一个机器人从坐标（0,0）的格子开始移动，它每次可以向左，向右，向上，向下移动一格，但不能进入行坐标和列坐标的位数之和大于k的格子。例如：当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18；但它不能进入方格（35,38），因为3 + 5+3+8 = 19.请问该机器人最多能到达多少个格子？
  要求：①对输入数据进行合法性判断②必须用回溯法③注意判断机器人是否可达的条件要合理④避免重复走过
  实现：
  public class Test {
    int hasPath(int m, int n, int sum) {
      if (m <= 0 || n <= 0 || sum < 0) {
        return 0;
      }
      boolean[] visited = new boolean[m * n];
      for (int i = 0; i < visited.length; i++) {
        visited[i] = false;
      }
      int index = hasPathCore(m, n, sum, 0, 0, visited);
      return index;
    }

    private int hasPathCore(int m, int n, int sum, int p, int q, boolean[] visited) {
      int count = 0;
      if (check(m, n, sum, p, q, visited)) {
        visited[p*n+q] = true;
        int index = 1 + hasPathCore(m, n, sum, p + 1, q, visited) + hasPathCore(m, n, sum, p - 1, q, visited) +
        hasPathCore(m, n, sum, p, q + 1, visited) + hasPathCore(m, n, sum, p, q - 1, visited);
        return index;
      }
      return 0;
    }

    private boolean check(int m, int n, int sum, int p, int q, boolean[] visited) {
      if (p >= 0 && q >= 0 && p < m && q < n && getSum(p) + getSum(q) < sum && !visited[n * p + q]) {
        return true;
      }
      return false;
    }

    private int getSum(int num) {
      int sum = 0;
      while (num > 0) {
        sum += (num % 10);
        num = num / 10;
      }
      return sum;
    }
  }
